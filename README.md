# FuturesMonitor

## Описание проекта

Этот проект реализует сервис для хранения и обработки цен фьючерсов с возможностью получения минимальной и максимальной цены за заданные промежутки времени. 
Сервис обеспечивает эффективное обновление и очистку данных, используя такие структуры данных, как `Map` и `Deque`.
Реализация с использованием Map и Deque обеспечивает эффективное добавление, удаление и получение данных. Использование этих структур данных позволяет достичь времени выполнения операций близкого к O(1), что делает этот сервис подходящим для работы с большими объемами данных. 
Рассмотренные альтернативы, такие как Sparse Table и матрицы минимумов и максимумов, были отклонены из-за их недостатков в производительности и сложности реализации.

## Реализация

### Структура данных

1. **Map**
    - Используется для хранения цен с временными метками. Это позволяет быстро добавлять новые данные и получать доступ к существующим данным по временной метке.

2. **Deque**
    - Двусторонняя очередь используется для хранения минимальных и максимальных значений за каждый промежуток времени. `Deque` позволяет эффективно добавлять и удалять элементы с обоих концов очереди.

### Основные методы

1. **addPrice(price: number): void**
    - Добавляет новую цену с текущей временной меткой и обновляет соответствующие `Deque` для каждого временного интервала.

2. **getMin(interval: string): number | null**
    - Возвращает минимальное значение за заданный интервал времени. Если `Deque` для этого интервала пуст, возвращается `null`.

3. **getMax(interval: string): number | null**
    - Возвращает максимальное значение за заданный интервал времени. Если `Deque` для этого интервала пуст, возвращается `null`.

4. **cleanupOldDataIfNeeded(currentTimestamp: number): void**
    - Удаляет устаревшие данные, которые старше 24 часов, и обновляет соответствующие `Deque`.

## Эффективность реализации

### Сложность

- **Map**:
    - Вставка: `O(1)`
    - Удаление: `O(1)`
    - Поиск: `O(1)`

- **Deque**:
    - Вставка (в начало и конец): `O(1)`
    - Удаление (с начала и конца): `O(1)`
    - Получение элемента (с начала и конца): `O(1)`

### Анализ эффективности

1. **Добавление цены**
    - Время выполнения: `O(1)` для добавления в `Map`.
    - Обновление `Deque` для каждого интервала: `O(1)` в худшем случае, так как каждый элемент добавляется и удаляется не более одного раза.

2. **Получение минимального и максимального значения**
    - Время выполнения: `O(1)` для получения значения из `Deque`.

3. **Очистка устаревших данных**
    - Время выполнения: `O(n)`, где `n` — количество элементов, так как каждый элемент проверяется и потенциально удаляется только один раз.

### Преимущества использования Deque

Использование `Deque` для хранения минимальных и максимальных значений за каждый временной интервал позволяет избежать полного обхода массива цен для поиска минимума и максимума. Это существенно улучшает производительность, особенно при больших объемах данных.

## Рассмотренные альтернативы

### 1. Простая сортировка и поиск по массиву
- **Преимущества**: Простота реализации.
- **Недостатки**: При каждом запросе минимального или максимального значения требуется сортировка массива, что занимает `O(n log n)` времени. Это неэффективно для больших объемов данных.

### 2. Поддержание отсортированного массива
- **Преимущества**: Быстрый доступ к минимальным и максимальным значениям.
- **Недостатки**: Вставка нового элемента в отсортированный массив занимает `O(n)` времени, что делает этот подход неэффективным при частом добавлении новых данных.

### 3. Sparse Table
- **Преимущества**: Быстрый доступ к минимальным и максимальным значениям в заданном диапазоне.
- **Недостатки**: `Sparse Table` требует предварительной обработки данных за `O(n log n)` времени и `O(n log n)` пространства. Этот метод не поддерживает динамическое добавление и удаление элементов, что делает его неподходящим для данной задачи.

### 4. Матрицы минимумов и максимумов
- **Преимущества**: Быстрый доступ к минимальным и максимальным значениям в любом подотрезке массива.
- **Недостатки**: Построение таких матриц требует `O(n^2)` времени и `O(n^2)` пространства. Это неэффективно для большого количества данных и не поддерживает динамическое добавление новых данных.

## Выбор оптимального решения

Использование `Map` и `Deque` было выбрано как оптимальное решение, обеспечивающее баланс между временем выполнения операций и сложностью реализации. Этот подход позволяет эффективно обрабатывать данные в реальном времени и поддерживать актуальность минимальных и максимальных значений за разные временные интервалы.

## Пример использования

```typescript
import { Injectable } from '@angular/core';
import { Deque } from '../../utils/deque-util/deque.util';

/**
 * Сервис для хранения и актуализирования цен на фьючерсы.
 */
@Injectable({
  providedIn: 'root'
})

export class FuturesPriceStoreService {
  /**
   * Хранение цен с ключом по времени.
   */
  private pricesMap: Map<number, number> = new Map();

  /**
   * Интервалы времени в миллисекундах для расчета минимумов и максимумов.
   */
  private intervals: { [key: string]: number } = {
    '5m': 5 * 60 * 1000,
    '15m': 15 * 60 * 1000,
    '1h': 60 * 60 * 1000,
    '4h': 4 * 60 * 60 * 1000,
    '24h': 24 * 60 * 60 * 1000,
  };

  /**
   * Deque для хранения минимумов.
   */
  private minDeque: { [key: string]: Deque<number> } = {};

  /**
   * Deque для хранения максимумов.
   */
  private maxDeque: { [key: string]: Deque<number> } = {};

  constructor() {
    // Инициализация Deque для каждого интервала времени
    for (const interval in this.intervals) {
      this.minDeque[interval] = new Deque();
      this.maxDeque[interval] = new Deque();
    }
  }

  /**
   * Добавить новую цену с текущим временем.
   * @param price - Новая цена.
   */
  addPrice(price: number): void {
    const timestamp = Date.now();
    this.pricesMap.set(timestamp, price);
    for (const interval in this.intervals) {
      this.updateDeque(this.minDeque[interval], price, timestamp, 'min', this.intervals[interval]);
      this.updateDeque(this.maxDeque[interval], price, timestamp, 'max', this.intervals[interval]);
    }
    this.cleanupOldDataIfNeeded(timestamp);
  }

  /**
   * Получить минимум за заданный интервал времени.
   * @param interval - Интервал времени.
   * @returns Минимальная цена за указанный интервал или null, если данных нет.
   */
  getMin(interval: string): number | null {
    const deque = this.minDeque[interval];
    return deque.isEmpty() ? null : deque.getFront()!;
  }

  /**
   * Получить максимум за заданный интервал времени.
   * @param interval - Интервал времени.
   * @returns Максимальная цена за указанный интервал или null, если данных нет.
   */
  getMax(interval: string): number | null {
    const deque = this.maxDeque[interval];
    return deque.isEmpty() ? null : deque.getFront()!;
  }

  /**
   * Обновление Deque для минимумов и максимумов.
   * @param deque - Deque для обновления.
   * @param price - Новая цена.
   * @param timestamp - Временная метка новой цены.
   * @param type - Тип обновления ('min' или 'max').
   * @param interval - Интервал времени.
   */
  private updateDeque(deque: Deque<number>, price: number, timestamp: number, type: 'min' | 'max', interval: number): void {
    while (!deque.isEmpty() && (type === 'min' ? deque.getBack()! > price : deque.getBack()! < price)) {
      deque.popBack();
    }
    deque.pushBack(price, timestamp);
    if (timestamp - deque.getFrontTimestamp()! >= interval) {
      deque.popFront();
    }
  }

  /**
   * Очистка устаревших данных.
   * @param currentTimestamp - Текущая временная метка.
   */
  private cleanupOldDataIfNeeded(currentTimestamp: number): void {
    const cutoff = currentTimestamp - this.intervals['24h'];
    for (const [timestamp, price] of this.pricesMap) {
      if (timestamp < cutoff) {
        this.pricesMap.delete(timestamp);
        for (const interval in this.intervals) {
          const minDeque = this.minDeque[interval];
          const maxDeque = this.maxDeque[interval];
          if (!minDeque.isEmpty() && minDeque.getFrontTimestamp() === timestamp) {
            minDeque.popFront();
          }
          if (!maxDeque.isEmpty() && maxDeque.getFrontTimestamp() === timestamp) {
            maxDeque.popFront();
          }
        }
      } else {
        break; // Цены отсортированы по времени, можно выйти после первой нестарой записи
      }
    }
  }
}
```

## Запуск приложения

Выполните команду `npx nx serve futures-monitor` для запуска сервера разработки.

## Сборка для продакшн

Выполните команду `npx nx build futures-monitor` для сборки приложения. Результаты сборки будут сохранены в выходной директории (например, `dist/` или `build/`), готовые к развертыванию.

## Установка необходимых пакетов

Перед использованием проекта убедитесь, что у вас установлены все необходимые пакеты. Выполните команду: `npm install`
